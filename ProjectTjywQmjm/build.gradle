import com.android.builder.model.ProductFlavor

apply plugin: 'com.android.application'

apply from: 'config/channel_product_flavors.gradle'

android {

    compileSdkVersion rootProject.ext.androidCompileSdkVersion
    buildToolsVersion rootProject.ext.androidBuildToolsVersion

    defaultConfig {

        minSdkVersion rootProject.ext.androidMinSdkVersion
        targetSdkVersion rootProject.ext.androidTargetSdkVersion

        applicationId rootProject.ext.proj[0].androidApplicationId
        versionCode rootProject.ext.proj[0].androidVersionCode
        versionName rootProject.ext.proj[0].androidVersionName

        multiDexEnabled true

        generatedDensities = []
    }

    aaptOptions {
        additionalParameters "--no-version-vectors"
    }

    lintOptions {
        checkReleaseBuilds false
        abortOnError false
    }

    dexOptions {
        javaMaxHeapSize "4g"
    }

    signingConfigs {

        release {
            storeFile file('src/release/adrTjywQmjm.jks')
            storePassword 'adrTjywQmjm'
            keyAlias 'adrTjywQmjm'
            keyPassword 'adrTjywQmjm'
            v2SigningEnabled false
        }
    }

    buildTypes {

        debug {
            zipAlignEnabled true
            minifyEnabled false
            shrinkResources false
            proguardFiles 'src/debug/proguard-rules.pro'
            versionNameSuffix '-beta'
            signingConfig signingConfigs.release
            debuggable true
        }

        release {
            zipAlignEnabled true
            minifyEnabled true
            shrinkResources true
            proguardFiles 'src/release/proguard-rules.pro'
            signingConfig signingConfigs.release
            debuggable false
        }
    }

    packagingOptions {
        exclude 'META-INF/LGPL2.1'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/NOTICE.txt'
    }

    cleanOutputs()

    applicationVariants.all { variant ->
        variant.outputs.each { output ->
            differentNameAssemble(output, variant.productFlavors, defaultConfig.versionCode)
        }
    }
}

def differentNameAssemble(output, productFlavors, versionCode) {
    def zipFile = output.outputFile
    for (ProductFlavor flavor : productFlavors) {
        def CLIENT_C_ID = flavor.getBuildConfigFields().get("CLIENT_C_ID").value
        CLIENT_C_ID = CLIENT_C_ID.replace("\"", "")
        def CLIENT_C_NAME = flavor.getBuildConfigFields().get("CLIENT_C_NAME").value
        CLIENT_C_NAME = CLIENT_C_NAME.replace("\"", "")

        def newApkName = null
        if (output.baseName.contains("release")) {
            newApkName = "adr_qmjm_master_${CLIENT_C_ID}_${CLIENT_C_NAME}_${versionCode}.apk"
        } else {
            newApkName = "adr_qmjm_master_${CLIENT_C_ID}_${CLIENT_C_NAME}_${versionCode}_${new Date().format('yyyyMMdd')}.apk"
        }

        output.outputFile = new File(zipFile.parent, newApkName)
    }

    zipFile.delete()
}

/**
 * 清理build/outputs/apk目录
 * */
def cleanOutputs() {
    File apkDir = new File("ProjectTjywQmjm/build/outputs/apk")
    if (apkDir.exists() && apkDir.isDirectory()) {
        apkDir.eachFile { outputFile ->
            if (outputFile.name.endsWith("apk")) {
                outputFile.delete()
            }
        }
    }
}

dependencies {
    compile project(':AtomNetwork')
    compile project(':AtomPublic')

    debugCompile libraryDependencies.leakcanaryDebug
    releaseCompile libraryDependencies.leakcanaryRelease
}
